#!/bin/bash

set -e #exit on non-zero exit codes
set -o pipefail # don't let errors propagate down pipelines

# CLI user interface
if [ "$1" == "-h" ]; then
    scriptname=$(basename "$0")
    usage="$scriptname -- install all the bokeh dependencies
    Usage:
        $scriptname [OPTIONS].. -- [EXTRA_CONDA_ARGS]..

    EXTRA_CONDA_ARGS:
        Posiitonal parameters passed after the option terminator '--' will
        be passed through to every conda command used to create the new envionrment

    Discription:
        Introspect the conda.recipe/meta.yaml from the root of the repo and
        then:
            1. Ensure that conda is installed.

               If conda is not found in PATH, the latest miniconda installer
               will be downloaded and run.  Since this script is intended for
               human users to run (as opposed to travis_install for CI), and
               since these users may be using conda for the first time, the
               script runs the miniconda installer in interactive mode

            2. Ensure that conda-build is installed.

               conda-build is an internal dependency of this script and must
               be installed in the active conda environment

            3.



    Examples:
        * Create a 'bokeh-py34' environment that uses Python 3.4

              $scriptname -e bokeh-py34 -- python=3.4

        * Create a doc-only environment called 'bokeh-docs'

              $scriptname -d -b 0 -r 0 -t 0 -e bokeh-docs


    Options:
        -h     show this help text

        -e     ENVIRONMENT were you want to install the dependencies, defaults to bokeh
        -b     install BUILD dependencies, defauls to true
        -r     install RUN dependencies, defauls to true
        -t     install TEST (and examples) dependencies, defauls to true
        -a     install ADDITIONAL image diff-related packages, defaults to false
        -d     install DOC dependencies, defaults to false
    "
    echo "$usage"
    exit 0
fi

# defauls
env=bokeh
build=true
run=true
test=true
doc=false
add=false

# handling of arguments
while getopts e:b:r:t:ad option
do
    case "${option}" in
        e) env=${OPTARG};;
        b) build=${OPTARG};;
        r) run=${OPTARG};;
        t) test=${OPTARG};;
        a) add=true;;
        d) doc=true;;
    esac
done


EXTRA_CONDA_ARGS=()
if [ "$OPTIND" -gt 1 ]; then
    # shift the options off the front of $@
    shift $(( $OPTIND - 1 ))
    # remaining "$@" are extra positional arguments
    EXTRA_CONDA_ARGS=("$@")
fi

function conda_env_does_not_exist {
    if conda env list | grep "^$1" >/dev/null 2>&1; then
        return 1
    else
        return 0
    fi
}

function conda_build_is_not_installed {
    if python -c 'from conda_build.metadata import MetaData' >/dev/null 2>&1; then
        return 1
    else
        return 0
    fi
}

# if CONDA_RECIPE happens to be set from env, use that path but otherwise use git
# to introspect the toplevel and use conda.recipe directory at the toplevel of the repo
export CONDA_RECIPE=${CONDA_RECIPE:-$(git rev-parse --show-toplevel)/conda.recipe}
function get_value {
    echo $(cat <<EOF | python -
import os
from conda_build.metadata import MetaData
print(" ".join([s.replace(" ", "") for s in MetaData(os.environ['CONDA_RECIPE']).get_value("$1")]))
EOF
    )
}

function conda_install {
    channels=$(echo $(get_value 'extra/channels') | sed -e 's/^\| \+/ -c /g')
    subcmd=install
    if conda_env_does_not_exist "$env"; then
        # TODO create a complete env.yaml and create at once
        #      so that we reduce risk of conflicting deps between
        #      different "sections" of the dependencies
        subcmd=create
    fi
    ( set -x; conda $subcmd -n $env $channels --yes "$@" "${EXTRA_CONDA_ARGS[@]}" )
}

function install_miniconda {
    MINICONDA_VERSION=${MINICONDA_VERSION:=latest}
    MINICONDA="Miniconda-$MINICONDA_VERSION-Linux-x86_64"
    MINICONDA_URL="http://repo.continuum.io/miniconda/$MINICONDA.sh"

    wget $MINICONDA_URL
    bash $MINICONDA.sh "$@"
    rm -rf $MINICONDA.sh
}

function conda_not_found_in_path {
    if type conda >/dev/null 2>&1; then
        return 1
    else
        return 0
    fi
}


if conda_not_found_in_path; then
    echo "conda is not found in your path. Installing miniconda."
    install_miniconda -p $HOME/miniconda
    source $HOME/miniconda/bin/activate root
fi

if conda_build_is_not_installed; then
    # conda_install requires that conda-build is installed in whatever env you
    # are using to run this script.  If we just installed conda (or you don't have it)
    # install it.
    
    echo "conda-build is not found in your path. Installing conda-build."
    (set -x ; conda install -n root --yes conda-build )
fi

if [ "$build" == "true" ]; then
    conda_install $(get_value "requirements/build")
    echo "BUILD dependecies installed."
fi

if [ "$run" == "true" ]; then
    conda_install $(get_value "requirements/run")
    echo "RUN dependecies installed."
fi

if [ "$test" == "true" ]; then
    conda_install $(get_value "test/requires")
    echo "TEST (and examples) dependecies installed."
fi

if [[ "$doc" == "true" ]]; then
    conda_install sphinx seaborn pyyaml ggplot
    echo "Documentation dependecies installed."
    echo
    echo "If you wish to build only the docs, you should now ensure you have the"
    echo "latest dev build of bokeh and the sample data by running:"
    echo ""
    echo "   source activate $env"
    echo "   conda install -n $env -c bokeh/channel/dev bokeh && bokeh sampledata"
    echo ""
    echo "Then to build the docs, you must:"
    echo ""
    echo "   cd $(git rev-parse --show-toplevel)/sphinx"
    echo "   make clean all"
    echo ""
    echo "After building, to serve and review your local docs:"
    echo ""
    echo "   cd $(git rev-parse --show-toplevel)/sphinx"
    echo "   make serve"
fi

if [[ "$add" == "true" ]]; then
    conda_install pdiff boto
    echo "Image diff-related dependecies installed."
fi
